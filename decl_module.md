---
title: decl_module!
---

The module declaration. This states the entry points that we handle. The macro takes care of the marshalling of arguments and dispatch.

Anyone can have these functions execute by signing and submitting an extrinsic. Ensure that calls into each of these execute in a time, memory and using storage space proportional to any costs paid for by the caller or otherwise the difficulty of forcing the call to happen.

Generally you'll want to split these into three groups:
- Public calls that are signed by an external account.
- Root calls that are allowed to be made only by the governance system.
- Inherent calls that are allowed to be made only by the block authors and validators.

Information about where this dispatch initiated from is provided as the first argument "origin". As such functions must always look like:

`fn foo(origin, bar: Bar, baz: Baz) -> Result;`

The `Result` is required as part of the syntax (and expands to the conventional dispatch result of `Result<(), &'static str>`).

When you come to `impl` them later in the module, you must specify the full type for `origin`:

`fn foo(origin: T::Origin, bar: Bar, baz: Baz) { ... }`

There are three entries in the `system::Origin` enum that correspond to the above bullets: `::Signed(AccountId)`, `::Root` and `::Inherent`. You should always match against them as the first thing you do in your function. There are three convenience calls in system that do the matching for you and return a convenient result: `ensure_signed`, `ensure_root` and `ensure_inherent`.

```rust
decl_module! {
	// Simple declaration of the `Module` type. Lets the macro know what its working on.
	pub struct Module<T: Trait> for enum Call where origin: T::Origin {
		/// This is your public interface. Be extremely careful.
		/// This is just a simple example of how to interact with
		/// the module from the external world.
		fn accumulate_dummy(origin, increase_by: T::Balance) -> Result;

		/// A privileged call; in this case it resets our dummy value to something new.
		fn set_dummy(new_dummy: T::Balance) -> Result;

		// The signature could also look like: `fn on_finalise()`
		fn on_finalise(_n: T::BlockNumber) {
			// Anything that needs to be done at the end of the block.
			// We just kill our dummy storage item.
			<Dummy<T>>::kill();
		}
	}
}
```

Below you may find the main implementantion block for the module. Methods defined in it fall into three broad categories:
- Implementations oispatch functions. The dispatch code generated by the module macro expects each of itsnctions to be implemented.
- Public interface.ese are functions that are `pub` and generally fall into inspector functions that do nwrite to storage and operation functions that do.
- Private functionshese are your usual private utilities unavailable to other modules.

First of all, there are two _extremely important_ things to remember:
- **MUST NOT PANIC**: Under no circumstances (save, perhaps, storage getting into an irreparably damaged state) must this function panic.
- **NO SIDE-EFFECTS ON ERROR**: This function must either complete totally (and return `Ok(())` or it must have no side-effects on storage and return `Err('Some reason')`.

The first is relatively easy to audit for - just ensure all panickers are removed from logic that executes in production (which you do anyway, right?!). To ensure the second is followed, you should do all tests for validity at the top of your function. This is stuff like checking the sender (`origin`) or that state is such that the operation makes sense.

Once you've determined that it's all good, then enact the operation and change storage.

If you can't be certain that the operation will succeed without substantial computation then you have a classic blockchain attack scenario. The normal way of managing this is to attach a bond to the operation. As the first major alteration of storage, reserve some value from the sender's account (`Balances` module has a `reserve` function for exactly this scenario). This amount should be enough to cover any costs of the
substantial execution in case it turns out that you can't proceed with the operation.

If it eventually transpires that the operation is fine and, therefore, that the expense of the checks should be borne by the network, then you can refund the reserved deposit. If, however, the operation turns out to be invalid and the computation is wasted, then you can burn it or repatriate elsewhere.

Security bonds ensure that attackers can't game it by ensuring that anyone interacting with the system either progresses it or pays for the trouble of faffing around with no progress.

**Warning:** If you don't respect these rules, it is likely that your chain will be attackable.


Ok, let's start with the implementation overview. Methods declared inside a module must be implemented somewhere. This is done in `impl` blocks, much like to normal Rust types. The only requirement is that impl need to be generic over `T: Trait` to be able to use SRML routines.

```rust
impl<T: Trait> Module<T> {
	// Implementation goes here
}
```

First goes `deposit_event` which is a private helper method that's used by other methods in this module. Since it wasn't declared in `decl_module!` it will not be visible to the outer world.

```rust
	/// Deposit one of this module's events.
	fn deposit_event(event: Event<T>) {
		<system::Module<T>>::deposit_event(<T as Trait>::Event::from(event).into());
	}
```

It performs a type conversion (todo: why?) and delegates resulting event to `deposit_event` method from `system` module that would deliver the event to all listeners. For more info on events see [todo].

Next goes `accumulate_dummy` method. This just increases the value of `Dummy` resource by `increase_by` amount:

```rust
	fn accumulate_dummy(origin: T::Origin, increase_by: T::Balance) -> Result {
		// This is a public call, so we ensure that the origin is some signed account.
		let _sender = ensure_signed(origin)?;

		// Here's the way to read and then modify the value.
		<Dummy<T>>::mutate(|dummy| {
			let new_dummy = dummy.map_or(increase_by, |dummy| dummy + increase_by);
			*dummy = Some(new_dummy);
		});

		// Let's deposit an event to let the outside world know this happened.
		Self::deposit_event(RawEvent::Dummy(increase_by));

		// All good.
		Ok(())
	}
```

It's important to check that caller is indeed has the right to invoke it and that the origin is some signed account. If check was successfull `ensure_signed` will return `AccountId` of the sender. If not, then method will return early due to `?` operator.

Storage could be accessed and modified in several ways:

```rust
	// Read the value of dummy from storage using accessor method:
	let dummy = Self::dummy();
	// Will also work using the `::get` on the storage item type itself:
	let dummy = <Dummy<T>>::get();

	// Calculate the new value. Accessors return Option<T>, so we use `map`.
	let new_dummy = dummy.map_or(
		increase_by,                // value to use if absent
		|dummy| dummy + increase_by // new value
	);

	// Put the new value into storage.
	<Dummy<T>>::put(new_dummy);
	// Will also work with a reference:
	<Dummy<T>>::put(&new_dummy);
```

Another way is to use `mutate` method that combines everything in one call:
```rust
	<Dummy<T>>::mutate(|dummy| {
		let new_dummy = dummy.map_or(increase_by, |dummy| dummy + increase_by);
		*dummy = Some(new_dummy);
	});
```

More info or storage may be found on [decl_storage!](decl_storage) page.

Sometimes it is needed to force the particular value. Since it's potentially dangerous operation it should be implemented as a privileged call. This doesn't have an `origin` parameter because it's not (directly) from an extrinsic, but rather the system as a whole has decided to execute it. Different runtimes have different reasons for allow privileged calls to be executed - we don't need to care why. Because it's privileged, we can assume it's a one-off operation and substantial processing/storage/memory can be used without worrying about gameability or attack scenarios.

```rust
	// Implementation of a privileged call to force new dummy value.
	fn set_dummy(new_value: T::Balance) -> Result {
		// Put the new value into storage.
		<Dummy<T>>::put(new_value);

		// All good.
		Ok(())
	}
```

See also:
- [Example module](https://github.com/paritytech/substrate/blob/master/srml/example/src/lib.rs) from SRML
- [decl_storage!](decl_storage)
- [decl_event!](decl_event)
